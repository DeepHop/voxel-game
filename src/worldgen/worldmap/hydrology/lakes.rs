use crate::worldgen::worldmap::terrain::elevation::{constants as c, craters::Crater, noise_sources::NoiseSources};
use noise::NoiseFn;

/// Returns a lake mask and modifies elevation in-place to carve/flatten lakes.
/// - Lakes are generated by noise and by filling craters near rivers.
/// - Craters near rivers are turned into lakes (flattened/lowered).
pub fn apply_lakes(
    elevation: &mut [Vec<f64>],
    flow: &[Vec<f64>],
    craters: &[Crater],
    noise: &NoiseSources,
    river_threshold: f64,
) -> Vec<Vec<bool>> {
    let width = elevation.len();
    let height = if width > 0 { elevation[0].len() } else { 0 };
    let mut lake_mask = vec![vec![false; height]; width];

    // 1. Noise-based lakes (as before)
    for x in 0..width {
        for y in 0..height {
            let nx = x as f64 / width as f64 - 0.5f64;
            let ny = y as f64 / height as f64 - 0.5f64;
            let lake_noise = (noise.lake.get([nx * c::LAKE_FREQ, ny * c::LAKE_FREQ]) * 0.5f64 + 0.5f64).powf(2.0f64);
            let mask = (1.0f64 - lake_noise).powf(2.0f64);
            if mask > 0.3 {
                // Mark as lake
                lake_mask[x][y] = true;
                // Lower elevation in lake areas
                elevation[x][y] -= mask * c::LAKE_LOWERING;
                // Flatten in lake areas
                elevation[x][y] = elevation[x][y] * (1.0 - c::LAKE_FLATTEN_BLEND * mask) + mask * 0.15;
            }
        }
    }

    // 2. Crater lakes: fill craters near rivers
    for crater in craters {
        let mut near_river = false;
        // Check if any river cell is within crater radius
        let min_x = (crater.x - crater.r).max(0.0) as usize;
        let max_x = (crater.x + crater.r).min(width as f64 - 1.0) as usize;
        let min_y = (crater.y - crater.r).max(0.0) as usize;
        let max_y = (crater.y + crater.r).min(height as f64 - 1.0) as usize;
        'outer: for x in min_x..=max_x {
            for y in min_y..=max_y {
                let dx = x as f64 - crater.x;
                let dy = y as f64 - crater.y;
                let dist = (dx * dx + dy * dy).sqrt();
                if dist < crater.r && flow[x][y] > river_threshold {
                    near_river = true;
                    break 'outer;
                }
            }
        }
        if near_river {
            // Fill the crater with water (lake): flatten/lower elevation, update mask
            for x in min_x..=max_x {
                for y in min_y..=max_y {
                    let dx = x as f64 - crater.x;
                    let dy = y as f64 - crater.y;
                    let dist = (dx * dx + dy * dy).sqrt();
                    if dist < crater.r {
                        let norm = 1.0 - (dist / crater.r);
                        // Lower and flatten
                        elevation[x][y] = elevation[x][y] * (1.0 - norm) + 0.12 * norm;
                        lake_mask[x][y] = true;
                    }
                }
            }
        }
    }

    // Clamp elevation after all modifications
    for x in 0..width {
        for y in 0..height {
            elevation[x][y] = elevation[x][y].clamp(0.0, 1.0);
        }
    }

    lake_mask
} 